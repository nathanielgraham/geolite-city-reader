import EventEmitter from 'events';
import { Params } from './body/params.js';
import { SafeString } from './util.js';
const ABSOLUTE = /^[a-zA-Z][a-zA-Z0-9]*:\/\//;
/**
 * Context class.
 */
class Context extends EventEmitter {
    constructor(app, req, res) {
        super({ captureRejections: true });
        /**
         * Partial content.
         */
        this.content = new Proxy({}, {
            get: function (target, name) {
                return new SafeString(target[name] ?? '');
            }
        });
        /**
         * WebSocket JSON mode.
         */
        this.jsonMode = false;
        /**
         * Router dispatch plan.
         */
        this.plan = null;
        /**
         * Non-persistent data storage and exchange for the current request.
         */
        this.stash = {};
        this._flash = undefined;
        this._params = undefined;
        this._session = undefined;
        this._ws = null;
        this.app = app;
        this.exceptionFormat = app.exceptionFormat;
        this.req = req;
        this.res = res;
        this.res.bindContext(this);
        this.log = app.log.child({ requestId: this.req.requestId });
    }
    [EventEmitter.captureRejectionSymbol](error) {
        this.exception(error);
    }
    /**
     * Select best possible representation for resource.
     */
    accepts(allowed) {
        const formats = this.app.mime.detect(this.req.get('Accept') ?? '');
        const stash = this.stash;
        if (typeof stash.ext === 'string')
            formats.unshift(stash.ext);
        if (allowed === undefined)
            return formats.length > 0 ? formats : null;
        const results = formats.filter(format => allowed.includes(format));
        return results.length > 0 ? results : null;
    }
    /**
     * Application config shortcut.
     */
    get config() {
        return this.app.config;
    }
    /**
     * Append partial content to `ctx.content` buffers.
     */
    async contentFor(name, content) {
        this.content[name] += content;
    }
    /**
     * Data storage persistent only for the next request.
     */
    async flash() {
        if (this._flash === undefined) {
            const session = await this.session();
            this._flash = new Proxy(session, {
                get: function (target, name) {
                    if (target.flash === undefined)
                        return undefined;
                    return target.flash[name];
                },
                set: function (target, name, value) {
                    const nextFlash = target.nextFlash ?? {};
                    nextFlash[name] = value;
                    target.nextFlash = nextFlash;
                    return true;
                }
            });
        }
        return this._flash;
    }
    /**
     * Handle WebSocket upgrade, used by servers.
     */
    handleUpgrade(ws) {
        this._ws = new WeakRef(ws);
        this.emit('connection', ws);
        ws.on('error', error => this.exception(error));
    }
    /**
     * Home directory shortcut.
     */
    get home() {
        return this.app.home;
    }
    /**
     * Check if WebSocket connection has been accepted.
     */
    get isAccepted() {
        return this.listenerCount('connection') > 0;
    }
    /**
     * Check if WebSocket connection has been established.
     */
    get isEstablished() {
        return this._ws !== null;
    }
    /**
     * Check if session is active.
     */
    get isSessionActive() {
        return this._session !== undefined;
    }
    /**
     * Check if HTTP request is a WebSocket handshake.
     */
    get isWebSocket() {
        return this.req.isWebSocket;
    }
    /**
     * Accept WebSocket connection and activate JSON mode.
     */
    json(fn) {
        this.jsonMode = true;
        return this.on('connection', fn);
    }
    /**
     * Model shortcut.
     */
    get models() {
        return this.app.models;
    }
    /**
     * GET and POST parameters.
     */
    async params(options) {
        if (this._params === undefined) {
            const req = this.req;
            const params = (this._params = new Params(req.query));
            for (const [name, value] of await req.form(options)) {
                params.append(name, value);
            }
        }
        return this._params;
    }
    /**
     * Accept WebSocket connection.
     */
    plain(fn) {
        return this.on('connection', fn);
    }
    /**
     * Send `302` redirect response.
     */
    async redirectTo(target, options = {}) {
        await this.res
            .status(options.status ?? 302)
            .set('Location', this.urlFor(target, options.values) ?? '')
            .send();
    }
    /**
     * Render dynamic content.
     */
    async render(options = {}, stash) {
        if (typeof options === 'string')
            options = { view: options };
        if (stash !== undefined)
            Object.assign(this.stash, stash);
        const app = this.app;
        const result = await app.renderer.render(this, options);
        if (result === null) {
            if (options.maybe !== true)
                throw new Error('Nothing could be rendered');
            return false;
        }
        return await app.renderer.respond(this, result, { status: options.status });
    }
    /**
     * Try to render dynamic content to string.
     */
    async renderToString(options, stash) {
        if (typeof options === 'string')
            options = { view: options };
        Object.assign(this.stash, stash);
        const result = await this.app.renderer.render(this, options);
        return result === null ? null : result.output.toString();
    }
    /**
     * Automatically select best possible representation for resource.
     */
    async respondTo(spec) {
        const formats = this.accepts() ?? [];
        for (const format of formats) {
            if (spec[format] === undefined)
                continue;
            await spec[format](this);
            return;
        }
        if (spec.any !== undefined) {
            await spec.any(this);
            return;
        }
        await this.res.status(204).send();
    }
    /**
     * Send static file.
     */
    async sendFile(file) {
        return await this.app.static.serveFile(this, file);
    }
    /**
     * Get JSON schema validation function.
     */
    schema(schema) {
        return this.app.validator.schema(schema);
    }
    /**
     * Persistent data storage for the next few requests.
     */
    async session() {
        if (this._session === undefined)
            this._session = (await this.app.session.load(this)) ?? {};
        return this._session;
    }
    /**
     * HTTP/WebSocket user agent shortcut.
     */
    get ua() {
        return this.app.ua;
    }
    /**
     * Generate URL for route of path.
     */
    urlFor(target, values, options = {}) {
        if (target === undefined || target === 'current') {
            if (this.plan === null)
                return null;
            const result = this.plan.render(values);
            return this._urlForPath(result.path, result.websocket, options);
        }
        if (target.startsWith('/'))
            return this._urlForPath(target, false, options);
        if (ABSOLUTE.test(target))
            return target;
        const route = this.app.router.lookup(target);
        if (route === null)
            return null;
        return this._urlForPath(route.render(values), route.hasWebSocket(), options);
    }
    /**
     * Generate URL for static file.
     */
    urlForFile(path) {
        if (ABSOLUTE.test(path))
            return path;
        return this.req.baseURL + this.app.static.filePath(path);
    }
    /**
     * Established WebSocket connection.
     */
    get ws() {
        return this._ws?.deref() ?? null;
    }
    _urlForPath(path, isWebSocket, options) {
        const query = options.query === undefined ? '' : '?' + new Params(options.query).toString();
        const url = this.req.baseURL + path + query;
        return isWebSocket ? url.replace(/^http/, 'ws') : url;
    }
}
export { Context };
//# sourceMappingURL=context.js.map