import cluster from 'cluster';
import http from 'http';
import https from 'https';
import os from 'os';
import { Stream } from 'stream';
import { URL } from 'url';
import { ServerRequest } from './server/request.js';
import { ServerResponse } from './server/response.js';
import { termEscape } from './util.js';
import { WebSocket } from './websocket.js';
import Path from '@mojojs/path';
import { WebSocketServer } from 'ws';
/**
 * Server class.
 */
export class Server {
    constructor(app, options = {}) {
        /**
         * Server URLs.
         */
        this.urls = [];
        this._servers = [];
        this.app = app;
        this.headersTimeout = options.headersTimeout;
        this.keepAliveTimeout = options.keepAliveTimeout;
        this.maxRequestsPerSocket = options.maxRequestsPerSocket;
        this.requestTimeout = options.requestTimeout;
        this.reverseProxy = options.reverseProxy ?? false;
        this._cluster = options.cluster ?? false;
        this._listen = options.listen ?? ['http://*:3000'];
        this._servers = [];
        this._quiet = options.quiet ?? false;
        this._workers = options.workers ?? os.cpus().length;
    }
    /**
     * Turn URL into listen arguments.
     */
    static listenArgsForURL(url) {
        const listen = [];
        const hostname = url.hostname;
        const port = url.port;
        const params = url.searchParams;
        if (port !== '' && hostname !== '') {
            listen.push(parseInt(port));
            listen.push(hostname === '*' ? '0.0.0.0' : hostname.replace(/^\[/, '').replace(/]$/, ''));
        }
        else if (params.has('fd') === true) {
            listen.push({ fd: parseInt(params.get('fd') ?? '') });
        }
        else {
            listen.push(undefined, '0.0.0.0');
        }
        return listen;
    }
    /**
     * Start server.
     */
    async start() {
        await this.app.hooks.runHook('server:start', this.app);
        if (this._cluster === true && cluster.isPrimary === true) {
            for (let i = 0; i < this._workers; i++) {
                cluster.fork();
            }
        }
        else {
            for (const location of this._listen) {
                await this._createServer(location);
            }
        }
    }
    /**
     * Stop server.
     */
    async stop() {
        await Promise.all(this._servers.map(async (server) => await new Promise(resolve => server.close(resolve))));
        await this.app.hooks.runHook('server:stop', this.app);
    }
    async _createServer(location) {
        const url = new URL(location);
        let isHttps = false;
        const options = {};
        if (url.protocol === 'https:') {
            const params = url.searchParams;
            options.cert = await new Path(params.get('cert') ?? '').readFile();
            options.key = await new Path(params.get('key') ?? '').readFile();
            isHttps = true;
        }
        await this.app.warmup();
        const wss = new WebSocketServer({ noServer: true });
        const server = (isHttps ? https : http).createServer(options, this._handleRequest.bind(this));
        this._servers.push(server);
        if (this.maxRequestsPerSocket !== undefined)
            server.maxRequestsPerSocket = this.maxRequestsPerSocket;
        if (this.headersTimeout !== undefined)
            server.headersTimeout = this.headersTimeout;
        if (this.keepAliveTimeout !== undefined)
            server.keepAliveTimeout = this.keepAliveTimeout;
        if (this.requestTimeout !== undefined)
            server.requestTimeout = this.requestTimeout;
        server.on('upgrade', this._handleUpgrade.bind(this, wss));
        if (process.env.MOJO_SERVER_DEBUG === '1') {
            server.on('connection', (socket) => {
                const stderr = process.stderr;
                socket.on('data', (chunk) => stderr.write(termEscape(`-- Server <<< Client\n${chunk}`)));
                const write = socket.write;
                socket.write = (chunk, cb) => {
                    stderr.write(termEscape(`-- Server >>> Client\n${chunk}`));
                    return write.apply(socket, [chunk, cb]);
                };
            });
        }
        return new Promise(resolve => {
            server.listen(...Server.listenArgsForURL(url), () => {
                const address = server.address();
                if (address === null || typeof address !== 'object')
                    throw new Error('Unknown server address');
                const host = address.family === 'IPv6' ? `[${address.address}]` : address.address;
                const realLocation = new URL(`${url.protocol}//${host}:${address.port}`);
                this.urls.push(realLocation);
                if (this._quiet === false) {
                    if (this._cluster === true) {
                        console.log(`[${process.pid}] Web application available at ${realLocation}`);
                    }
                    else {
                        console.log(`Web application available at ${realLocation}`);
                    }
                }
                resolve();
            });
        });
    }
    _handleRequest(req, raw) {
        const app = this.app;
        const socket = req.socket;
        const ctx = app.newContext(this._prepareRequest(req, socket, false), new ServerResponse(function (res, body) {
            _sendResponse(res, body, raw);
        }));
        raw.on('finish', () => ctx.emit('finish'));
        app.handleRequest(ctx).catch(error => ctx.exception(error));
    }
    _handleUpgrade(wss, req, socket, head) {
        const app = this.app;
        const ctx = app.newContext(this._prepareRequest(req, socket, true), new ServerResponse(function (res, body) {
            _sendResponse(res, body, new http.ServerResponse(req));
        }));
        app
            .handleRequest(ctx)
            .then(() => {
            if (ctx.isAccepted === true) {
                wss.handleUpgrade(req, socket, head, ws => {
                    ctx.handleUpgrade(new WebSocket(ws, null, { jsonMode: ctx.jsonMode }));
                });
            }
            else {
                socket.destroy();
            }
        })
            .catch(error => {
            if (ctx.isAccepted === false)
                socket.destroy();
            return ctx.exception(error);
        });
    }
    _prepareRequest(req, socket, isWebSocket) {
        return new ServerRequest({
            body: req,
            headers: req.rawHeaders,
            isSecure: socket.encrypted ?? false,
            isWebSocket: isWebSocket,
            method: req.method,
            remoteAddress: socket.remoteAddress,
            reverseProxy: this.reverseProxy,
            url: req.url
        });
    }
}
function _sendHeaders(res, raw) {
    const statusCode = res.statusCode;
    const statusMessage = res.statusMessage;
    const headers = res.headers.toArray();
    if (statusMessage === null) {
        raw.writeHead(statusCode, headers);
    }
    else {
        raw.writeHead(statusCode, statusMessage, headers);
    }
}
function _sendResponse(res, body, raw) {
    if (typeof body === 'string' || Buffer.isBuffer(body)) {
        res.length(Buffer.byteLength(body));
        _sendHeaders(res, raw);
        raw.end(body);
    }
    else if (body instanceof Stream) {
        _sendHeaders(res, raw);
        body.pipe(raw);
    }
    else {
        _sendHeaders(res, raw);
        raw.end();
    }
}
//# sourceMappingURL=server.js.map